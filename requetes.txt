1/ L’ensemble des jeux critiqués disponibles dans un thème donné, classés par mécaniques.

Stratégie: Avoir listes des jeux du themes => Verifier qu'ils ont été critiqués => les trier par mécaniques

SELECT DISTINCT J.nom_jeu, M.description_mecanique //(à enlever apres test de tri)
FROM JEUX as J NATURAL JOIN MECANIQUES_UTIL NATURAL JOIN MECANIQUES as M NATURAL JOIN THEMES_UTIL
WHERE id_theme = (                  // Relier l'intitulé a l'id
        SELECT id_theme
        FROM THEMES
        WHERE intitule_theme = ? 
    )
    AND id_jeu in (                 // Verifier que le jeu est critiqué
        SELECT DISTINCT id_jeu
        FROM CONFIGURATIONS
    )
ORDER BY description_mecanique ASC // Trier par mecanique

2/  Pour un joueur donné, la liste des commentaires se référant à un jeu dans une de ses
catégories préférées.

Stratégie: Avoir mécaniques pref => liste des jeux de ces mécaniques => liste des commentaires de ces jeux

SELECT note_avis, commentaire_avis, date_avis, nom_jeu
FROM AVIS NATURAL JOIN CONFIGURATIONS NATURAL JOIN JEUX
WHERE id_jeu IN (                       
    SELECT DISTINCT id_jeu 
    FROM MECANIQUES_UTIL NATURAL JOIN MECANIQUES_PREF
    WHERE id_joueur = (
        SELECT id_joueur
        FROM JOUEURS
        WHERE pseudo_joueur = ?
    )
)
ORDER BY id_jeu; // Pour grouper tous les avis d'un meme jeu 

3/ Pour un commentaire la liste des joueurs qui l'ont apprecie

Stratégie: Avoir la liste des jugements positifs d'un avis => remonter aux joueurs qui ont fait ces jugements

SELECT pseudo_joueur
FROM JUGEMENTS NATURAL JOIN JOUEURS 
WHERE est_positif = 1
    AND id_avis = ?

4/ Les joueurs, classés selon le nombre de jeux qu’ils ont notés

SELECT id_joueur, pseudo_joueur, COUNT(id_avis) as Avis_donne
FROM JOUEURS LEFT OUTER JOIN AVIS USING(id_joueur)
GROUP BY id_joueur, pseudo_joueur
ORDER BY Avis_donne DESC

5/ La liste des n commentaires les plus récents

SELECT *
FROM Avis
ORDER BY date_avis DESC
LIMIT ?  

6/ Le commentaire qui laisse le moins indifférent

SELECT id_avis, COUNT(*) as Jugements_obtenus
FROM Jugements
GROUP BY id_avis
HAVING COUNT(*) = (
    SELECT COUNT(*)
    FROM Jugements
    GROUP BY id_avis
    ORDER BY COUNT(*) DESC 
    LIMIT 1
)

7/ On procédera au classement des jeux selon une moyenne dans laquelle chaque note est pondérée 
par l’indice de confiance du commentaire correspondant.


Classement des jeux suivant la moyenne des avis:
SELECT id_jeu, AVG(note_avis) as Note
FROM Avis
GROUP BY id_jeu
ORDER BY Note

Calcul de l'indice de confiance:
SELECT id_avis, (1+COUNT(estPositif))/(1+COUNT(estNegatif)) as Indice_confiance
FROM Jugements
GROUP BY id_avis

Seule solution que je vois pour cette requete:
Ajouter un attribut indice_confiance dans la table Avis.
Mettre en place un trigger insert sur la table Jugement qui modifie l'attribut Indice_confiance de chaque avis. 
De cette facon, il est beaucoup plus facile d'avoir acces a l'indice de confiance et donc la ponderation puis moyenne est triviale. 

Le trigger en question:
CREATE OR REPLACE TRIGGER Ind_conf
AFTER INSERT OR UPDATE OR DELETE ON Jugements
FOR EACH ROW
BEGIN
    UPDATE Avis as A
    SET indice_confiance = (
        SELECT (1+COUNT(estPositif))/(1+COUNT(estNegatif))
        FROM Jugements
        WHERE id_avis = ?
        GROUP BY id_avis
    )
    WHERE A.id_avis = new.id_avis
END;

Requete Finale (??):
SELECT id_jeu, AVG(A.note * A.indice_confiance) as Note
FROM Avis AS A
GROUP BY id_avis
ORDER BY Note
